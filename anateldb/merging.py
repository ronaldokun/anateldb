# AUTOGENERATED! DO NOT EDIT! File to edit: ..\nbs\merging.ipynb.

# %% auto 0
__all__ = ['MAX_DIST', 'COLS', 'check_add_row', 'get_subsets', 'merge_closer', 'merge_triple', 'check_merging',
           'get_frequencies_set', 'merge_aero']

# %% ..\nbs\merging.ipynb 2
from itertools import product
import pandas as pd
from geopy.distance import geodesic

from .reading import read_icao, read_aisw, read_aisg
MAX_DIST = 10 #Km
COLS = ['Frequency', 'Latitude', 'Longitude', 'Description']

# %% ..\nbs\merging.ipynb 4
def check_add_row(df, # DataFrame para mesclar adicionar o registro
                  f, # Frequência (MHz) em análise do registro 
                  rows, # Lista de registros para mesclar
                  dicts, # Dicionário fonte dos registros
)->pd.DataFrame: # DataFrame com o registro adicionado
    """Mescla os registros em `rows` de frequência `f` e os adiciona como uma linha do DataFrame `df`
    Os registros em `rows` somente são mesclados se ainda constarem nos dicionários fonte `dicts`
    Após a mesclagem, os registros são removidos dos dicionários fonte `dicts`   
    """
    if all(row.Index in dict for row, dict in zip(rows, dicts)):
        lat = sum(row.Latitude for row in rows) / len(rows)
        long = sum(row.Longitude for row in rows) / len(rows)
        desc = ' | '.join(row.Description for row in rows)
        d = {'Frequency': f, 'Latitude': lat, 'Longitude': long, 'Description': desc}
        for row, reg in zip(rows.copy(), dicts.copy()):
            reg.pop(row.Index)
        return pd.concat([df, pd.DataFrame(d, index=[0])], ignore_index=True)
    return df


# %% ..\nbs\merging.ipynb 5
def get_subsets(f, # Frequência (MHz) em análise do registro
                *dfs, # Conjunto de DataFrames a serem analisados
)->list: # Lista com subconjuntos de registros de frequência `f` para cada df em `dfs`
    """Retorna os subconjuntos de registros de frequência `f` em cada dataframe `dfs`
    Os subconjuntos são retornados em forma de dicionário, onde a chave é o índice do registro
    """
    return [{s.Index: s for s in df.loc[df.Frequency == f, COLS].itertuples()} for df in dfs]


# %% ..\nbs\merging.ipynb 6
def merge_closer(frequencies, # Lista de frequências em comum
                 df, # DataFrame de saída
                 df_left, # DataFrame 1 de entrada da esquerda
                 df_right # DataFrame 2 de entrada da direita
)->pd.DataFrame: # DataFrame de saída com as frequências em comum de `df_left` e `df_right` mescladas ou inseridas individualmente
    """Mescla os registros de frequência `frequencies` de `df_left` e `df_right` em `df`
    Essa função é utilizada para mesclar registros que possuem frequências em comum listadas em `frequencies`
    Os registros são mesclados se a distância entre eles for menor que `MAX_DIST`
    do contrário são adicionados individualmente como uma linha no DataFrame de saída `df`	
    """
    for f in frequencies:
        sa, sb = get_subsets(f, df_left, df_right)
        if all([sa, sb]): # Somente há registros para mesclar se estiverem nos dois conjuntos
            for fa, fb in list(product(sa.copy().values(), sb.copy().values())):
                if geodesic((fa.Latitude, fa.Longitude), (fb.Latitude, fb.Longitude)).km <= MAX_DIST:
                    df = check_add_row(df, f, [fa, fb], [sa, sb]) 
        for reg in [sa, sb]: # Do contrário os registros são adicionados individualmente ao DataFrame
            for r in reg.copy().values():
                df = check_add_row(df, f, [r], [reg])
    return df


# %% ..\nbs\merging.ipynb 8
def merge_triple(frequencies, # Lista de frequências em comum
                 df, # DataFrame de saída 
                 df_left, # DataFrame 1 de entrada
                 df_middle, # DataFrame 2 de entrada 
                 df_right, # DataFrame 3 de entrada 
)->pd.DataFrame: # DataFrame de saída com as frequências `frequencies` de `df_left`, `df_middle` e `df_right` mescladas ou inseridas individualmente em `df`
    """Mescla os registros de frequência `frequencies` de `df_left`, `df_middle` e `df_right` em `df`
    Essa função é utilizada para mesclar registros que possuem frequências em comum listadas em `frequencies`
    Os registros são mesclados se a distância entre eles for menor que `MAX_DIST`
    do contrário são adicionados individualmente como uma linha no DataFrame de saída `df`
    """
    for f in frequencies:
        sa, sb, sc = get_subsets(f, df_left, df_middle, df_right)
        if all([sa, sb, sc]):
            for fa, fb, fc in list(product(sa.copy().values(), sb.copy().values(), sc.copy().values())):
                dab = geodesic((fa.Latitude, fa.Longitude), (fb.Latitude, fb.Longitude)).km
                dac = geodesic((fa.Latitude, fa.Longitude), (fc.Latitude, fc.Longitude)).km
                dbc = geodesic((fb.Latitude, fb.Longitude), (fc.Latitude, fc.Longitude)).km
                if all(d <= MAX_DIST  for d in [dab, dac, dbc]):
                    df = check_add_row(df, f, [fa, fb, fc], [sa, sb, sc])
                elif all(d > MAX_DIST  for d in [dac, dbc]):
                    df = check_add_row(df, f, [fa, fb], [sa, sb])
                elif all(d > MAX_DIST  for d in [dab, dac]):
                    df = check_add_row(df, f, [fa, fc], [sb, sc])
                elif all(d > MAX_DIST for d in [dab, dbc]):
                    df = check_add_row(df, f, [fa, fc], [sa, sc])
        for reg in [sa, sb, sc]:
            for r in reg.copy().values():
                df = check_add_row(df, f, [r], [reg])        
    return df

# %% ..\nbs\merging.ipynb 9
def check_merging(df, # Dataframe to check
                  freqs, # Sets of Frequencies
                  dfs, # Dataframes sources of `df`
):    # True se a mesclagem dos registros de `icao`, `aisw` e `aisg` no DataFrame `df` está consistente
    """Verifica a validade da mesclagem dos registros de `icao`, `aisw` e `aisg` em `df`"""
    assert sum(df[df.Frequency.isin(f)].shape[0] for f in freqs) == len(df), "Número de registros inconsistente"
    single_sum = df.Description.str.split('\|').apply(lambda x: len(x)).sum()
    assert single_sum == sum(len(d) for d in dfs), "Número de registros inconsistente"

# %% ..\nbs\merging.ipynb 10
def get_frequencies_set(df1: pd.DataFrame, # DataFrame 1
                        df2: pd.DataFrame, # DataFrame 2
                        df3: pd.DataFrame, # DataFrame 3
)-> tuple: # Tupla com todos os subconjuntos do Diagrama de Venn das frequências de `df1`, `df2` e `df3`
    """Retorna todos os conjuntos de frequências do Diagrama de Venn entre os registros de `df1`, `df2` e `df3`"""
    f1 = set(df1.Frequency.tolist())
    f2 = set(df2.Frequency.tolist())
    f3 = set(df3.Frequency.tolist())
    ABC = f1.intersection(f2).intersection(f3)
    AB = f1.intersection(f2).difference(ABC)
    BC = f2.intersection(f3).difference(ABC)
    AC = f1.intersection(f3).difference(ABC)
    A = f1.difference(f2).difference(f3)
    B = f2.difference(f3).difference(f1)
    C = f3.difference(f1).difference(f2)
    return A, B, C, AB, AC, BC, ABC

# %% ..\nbs\merging.ipynb 11
def merge_aero(folder, # Pasta onde estão os arquivos de entrada
)->pd.DataFrame: # DataFrame com as bases da Aeronáutica com registros mesclados
    """Mescla os registros de mesma frequência e próximos dos arquivos da aeronáutica em `folder`"""
    icao = read_icao(folder).loc[:, COLS].drop_duplicates().reset_index(drop=True)
    aisw = read_aisw(folder).loc[:, COLS].drop_duplicates().reset_index(drop=True)
    aisg = read_aisg(folder).loc[:, COLS].drop_duplicates().reset_index(drop=True)
    df = pd.DataFrame(columns=COLS)
    A, B, C, AB, AC, BC, ABC = get_frequencies_set(icao, aisw, aisg)
    df = merge_closer(AB, df, icao, aisw)
    df = merge_closer(AC, df, icao, aisg)
    df = merge_closer(BC, df, aisw, aisg)
    df = merge_triple(ABC, df, icao, aisw, aisg)
    df = pd.concat([df, icao[icao.Frequency.isin(A)], aisw[aisw.Frequency.isin(B)], aisg[aisg.Frequency.isin(C)]])
    df = df.drop_duplicates().sort_values('Frequency').reset_index(drop=True)
    check_merging(df, [A, B, C, AB, AC, BC, ABC], [icao, aisw, aisg])
    return df
